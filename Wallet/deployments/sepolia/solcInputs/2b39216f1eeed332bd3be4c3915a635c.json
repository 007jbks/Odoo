{
  "language": "Solidity",
  "sources": {
    "contracts/wallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor() {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n/**\n * @title ECommerceWallet\n * @dev A simplified wallet contract for an e-commerce site where the backend\n * manages user token balances.\n * This contract is owned by a single address (the backend's address) which\n * has the sole authority to add and subtract tokens from user accounts.\n * All balance changes are recorded on the blockchain via events for transparency.\n */\ncontract ECommerceWallet is Ownable {\n    // Mapping from user address (or unique ID represented as address) to their token balance\n    mapping(address => uint256) private _balances;\n    \n    // Mapping from user ID to their assigned wallet address\n    mapping(string => address) private _userWallets;\n    \n    // Mapping to check if a wallet address is registered\n    mapping(address => bool) private _isRegistered;\n    \n    // Counter for generating unique wallet addresses\n    uint256 private _walletCounter;\n\n    // Event emitted when tokens are added to a user's balance\n    event TokensAdded(address indexed user, uint256 amount, uint256 newBalance);\n\n    // Event emitted when tokens are subtracted from a user's balance\n    event TokensSubtracted(address indexed user, uint256 amount, uint256 newBalance);\n    \n    // Event emitted when a new wallet is created for a user\n    event WalletCreated(string indexed userId, address indexed walletAddress);\n\n    /**\n     * @dev Creates a new wallet address for a user identified by userId.\n     * Only the contract owner (backend) can call this function.\n     * @param userId The unique identifier for the user (e.g., email, username, or UUID).\n     * @return walletAddress The generated wallet address for the user.\n     */\n    function createWallet(string memory userId) public onlyOwner returns (address) {\n        require(bytes(userId).length > 0, \"ECommerceWallet: userId cannot be empty\");\n        require(_userWallets[userId] == address(0), \"ECommerceWallet: wallet already exists for this user\");\n        \n        // Generate a deterministic address based on contract address, userId, and counter\n        address walletAddress = address(uint160(uint256(keccak256(abi.encodePacked(\n            address(this),\n            userId,\n            _walletCounter,\n            block.timestamp\n        )))));\n        \n        // Ensure the generated address is not already registered\n        while (_isRegistered[walletAddress]) {\n            _walletCounter++;\n            walletAddress = address(uint160(uint256(keccak256(abi.encodePacked(\n                address(this),\n                userId,\n                _walletCounter,\n                block.timestamp\n            )))));\n        }\n        \n        _userWallets[userId] = walletAddress;\n        _isRegistered[walletAddress] = true;\n        _walletCounter++;\n        \n        emit WalletCreated(userId, walletAddress);\n        return walletAddress;\n    }\n\n    /**\n     * @dev Returns the wallet address for a given userId.\n     * @param userId The unique identifier for the user.\n     * @return The wallet address associated with the userId.\n     */\n    function getWalletAddress(string memory userId) public view returns (address) {\n        return _userWallets[userId];\n    }\n\n    /**\n     * @dev Checks if a wallet address is registered in the system.\n     * @param walletAddress The address to check.\n     * @return True if the address is registered, false otherwise.\n     */\n    function isWalletRegistered(address walletAddress) public view returns (bool) {\n        return _isRegistered[walletAddress];\n    }\n\n    /**\n     * @dev Adds a specified `amount` of tokens to a `user`'s balance.\n     * Only the contract owner (backend) can call this function.\n     * @param user The address (or unique ID) of the user whose balance will be increased.\n     * @param amount The amount of tokens to add.\n     */\n    function addTokens(address user, uint256 amount) public onlyOwner {\n        require(user != address(0), \"ECommerceWallet: cannot add tokens to the zero address\");\n        _balances[user] += amount; // Safely adds tokens (handles overflow if amount is huge, but unlikely for balances)\n        emit TokensAdded(user, amount, _balances[user]);\n    }\n\n    /**\n     * @dev Convenience function to add tokens using userId instead of address.\n     * Only the contract owner (backend) can call this function.\n     * @param userId The unique identifier for the user.\n     * @param amount The amount of tokens to add.\n     */\n    function addTokensByUserId(string memory userId, uint256 amount) public onlyOwner {\n        address userAddress = _userWallets[userId];\n        require(userAddress != address(0), \"ECommerceWallet: wallet not found for this user\");\n        addTokens(userAddress, amount);\n    }\n\n    /**\n     * @dev Subtracts a specified `amount` of tokens from a `user`'s balance.\n     * Only the contract owner (backend) can call this function.\n     * Requires that the user has sufficient balance.\n     * @param user The address (or unique ID) of the user whose balance will be decreased.\n     * @param amount The amount of tokens to subtract.\n     */\n    function subtractTokens(address user, uint256 amount) public onlyOwner {\n        require(user != address(0), \"ECommerceWallet: cannot subtract tokens from the zero address\");\n        require(_balances[user] >= amount, \"ECommerceWallet: insufficient balance\");\n        _balances[user] -= amount; // Safely subtracts tokens\n        emit TokensSubtracted(user, amount, _balances[user]);\n    }\n\n    /**\n     * @dev Convenience function to subtract tokens using userId instead of address.\n     * Only the contract owner (backend) can call this function.\n     * @param userId The unique identifier for the user.\n     * @param amount The amount of tokens to subtract.\n     */\n    function subtractTokensByUserId(string memory userId, uint256 amount) public onlyOwner {\n        address userAddress = _userWallets[userId];\n        require(userAddress != address(0), \"ECommerceWallet: wallet not found for this user\");\n        subtractTokens(userAddress, amount);\n    }\n\n    /**\n     * @dev Returns the current token balance of a specific `user`.\n     * @param user The address (or unique ID) of the user.\n     * @return The balance of the user.\n     */\n    function getBalance(address user) public view returns (uint256) {\n        return _balances[user];\n    }\n\n    /**\n     * @dev Convenience function to get balance using userId instead of address.\n     * @param userId The unique identifier for the user.\n     * @return The balance of the user.\n     */\n    function getBalanceByUserId(string memory userId) public view returns (uint256) {\n        address userAddress = _userWallets[userId];\n        require(userAddress != address(0), \"ECommerceWallet: wallet not found for this user\");\n        return _balances[userAddress];\n    }\n}"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}